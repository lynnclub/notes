---
title: "算法"
date: 2023-09-19T14:03:44+08:00
draft: true
---

# 算法

时间复杂度计算

二分法 n/2^k=1，即k=log2n，底数省略，时间复杂度O(log n)

排序

1. 冒泡（Bubble Sort）：比较相邻的元素，如果第一个比第二个大就交换。
2. 选择（Select Sort）：每次从未排序序列中找到最小值，放在已排序序列。
3. 插入（Insertion Sort）：第一个元素认为已排序，对已排序序列比较后插入到正确位置。
4. 希尔（Shell’s Sort）：对插入排序的改进，分割成若干子序列分别进行插入排序，再对全体序列做一次插入排序。
5. 归并：将序列对半分割，递归到底，再把两个排序好的子序列合并。
6. 快速：选择基准，排序分区，再对分区子序列递归。
7. 堆：近似完全二叉树。
8. 计数：非比较排序，统计元素值出现的次数，再还原排序好的序列。
9. 桶
10. 基数

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2d5055f3-7c71-4060-bf7d-07d67a65bb85/Untitled.png)

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b8512832-235c-43db-b9a3-be4bed497c88/image1.png

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/815e2758-3aff-47ba-a0ca-790f91fb12ce/image2.png

冒泡排序

```go
func BubbleSort(list []int) {
    n := len(list)
    // 在一轮中有没有交换过
    didSwap := false

    // 进行 N-1 轮迭代
    for i := n - 1; i > 0; i-- {
        // 每次从第一位开始比较，比较到第 i 位就不比较了，因为前一轮该位已经有序了
        for j := 0; j < i; j++ {
            // 如果前面的数比后面的大，那么交换
            if list[j] > list[j+1] {
                list[j], list[j+1] = list[j+1], list[j]
                didSwap = true
            }
        }

        // 如果在一轮中没有交换过，那么已经排好序了，直接返回
        if !didSwap {
            return
        }
    }
}
```

选择排序

```go
func SelectSort(list []int) {
    n := len(list)
    // 进行 N-1 轮迭代
    for i := 0; i < n-1; i++ {
        // 每次从第 i 位开始，找到最小的元素
        min := list[i] // 最小数
        minIndex := i  // 最小数的下标
        for j := i + 1; j < n; j++ {
            if list[j] < min {
                // 如果找到的数比上次的还小，那么最小的数变为它
                min = list[j]
                minIndex = j
            }
        }

        // 这一轮找到的最小数的下标不等于最开始的下标，交换元素
        if i != minIndex {
            list[i], list[minIndex] = list[minIndex], list[i]
        }
    }
}
```

插入排序

```go
func InsertSort(list []int) {
    n := len(list)
    // 进行 N-1 轮迭代
    for i := 1; i <= n-1; i++ {
        deal := list[i] // 待排序的数
        j := i - 1      // 待排序的数左边的第一个数的位置

        // 如果第一次比较，比左边的已排好序的第一个数小，那么进入处理
        if deal < list[j] {
            // 一直往左边找，比待排序大的数都往后挪，腾空位给待排序插入
            for ; j >= 0 && deal < list[j]; j-- {
                list[j+1] = list[j] // 某数后移，给待排序留空位
            }
            list[j+1] = deal // 结束了，待排序的数插入空位
        }
    }
}
```

快速排序

```go
func quickSort(arr []int, begin, end int) {
	if begin < end {
		i := begin + 1 // 将array[begin]作为基准数，因此从array[begin+1]开始与基准数比较！
    j := end       // array[end]是数组的最后一位

    // 没重合之前
    for i < j {
        if array[i] > array[begin] {
            array[i], array[j] = array[j], array[i] // 交换
            j--
        } else {
            i++
        }
    }

    /* 跳出while循环后，i = j。
     * 此时数组被分割成两个部分  -->  array[begin+1] ~ array[i-1] < array[begin]
     *                        -->  array[i+1] ~ array[end] > array[begin]
     * 这个时候将数组array分成两个部分，再将array[i]与array[begin]进行比较，决定array[i]的位置。
     * 最后将array[i]与array[begin]交换，进行两个分割部分的排序！以此类推，直到最后i = j不满足条件就退出！
     */
    if array[i] >= array[begin] { // 这里必须要取等“>=”，否则数组元素由相同的值组成时，会出现错误！
        i--
    }

		quickSort(arr, begin, i-1)
		quickSort(arr, i+1, end)
	}
}
```

深度优先遍历是先序遍历，广度优先遍历是层次遍历。

1000亿整数文件取最大的100个：先取100构建二叉树，迭代淘汰。